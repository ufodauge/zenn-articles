{
  "title": "中途半端Rustからの再学習",
  "closed": true,
  "archived": false,
  "created_at": "2023-06-30",
  "comments": [
    {
      "author": "agdf",
      "created_at": "2023-06-30",
      "body_markdown": "## 現状\n\nコンパイラに従いながらある程度コードを書くことができ、所有権や可変変数、借用チェックなどがわかる。\n`Result` 型や `Option` 型が使え、 `anyhow` を用いたエラーハンドリングはわかるが、最適なエラーハンドリングには悩むところがある。\nまた、`struct` と `impl` が使えるが、 `trait` や ライフタイムなどはイマイチわかってない。\n`Box` `dyn` もよくわかってない。\nようするに中途半端であやふや。\n\n他の言語は、lua, js/ts が歴の長い使用言語で、 C/C++, C#, Python は時折触る程度。",
      "body_updated_at": "2023-06-30"
    },
    {
      "author": "agdf",
      "created_at": "2023-06-30",
      "body_markdown": "## トレイト(1)\n\n`interface` と似たものであることはわかっているが、具体的にどう違うのか、何ができるのか、という段階。\n\nトレイトは \n\n> * データ型を分類するための仕組み\n> * 型に対して共通の振る舞いを定義できる\n> * ジェネリック型にトレイト境界として指定し、インスタンスを制約できる\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/497a21\n\nトレイトは下記のようにして定義。\n\n```rust\ntrait Entry {\n    fn get_name(&self) -> &'static str {\n        \"Undefined\"\n    }\n    fn get_parent(&self) -> &'static Self;\n    fn new(name: &str) -> Self;\n}\n```\n\n`get_name` のように、デフォルト実装もできる。\n多分実装のときに困るが、コンパイルエラーは出ないので一旦このままで。\n\n:::message\n最初は下記のように書こうとした。\n\n```rust\ntrait Entry {\n    fn get_name(&self) -> &str;\n    fn get_parent(&self) -> &Entry;\n    fn new(name: &str) -> Entry;\n}\n```\n\n### &str -> &'static str\n\n下記エラー内容\n```\nconsider using the `'static` lifetime: `'static `rustcE0106\n\nmissing lifetime specifier\nthis function's return type contains a borrowed value, but there is no value for it to be borrowed fromrustcClick for full compiler diagnostic\n```\n\nライフタイムの話が絡んでるようなので次のスクラップで詳しく突き詰めたい。\n\n### Entry -> Self\n\n`Entry` はトレイトだから返せる訳がないが、 `Self` はこの場合実装先の `Self` を指しているということなのだろうか？\nRust における `Self` に関してなにか勘違いしている可能性がある。\n:::",
      "body_updated_at": "2023-06-30"
    },
    {
      "author": "agdf",
      "created_at": "2023-06-30",
      "body_markdown": "## ライフタイム(1)\n\nスコープを抜けたらオブジェクトが死ぬことはわかっているが、 `'static` とか `'a` とか強要されるのなんですか？　状態。\n\n> 複数の型の可能性があるときには、型を注釈しなければなりません。 \n> 同様に、参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。 \n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/fbd089\n\n関数や構造体の実装において時折 `<'a>` のようなものが強要されるのはこれか。\n\n:::details -\n> ライフタイムの主な目的は、ダングリング参照を回避することです。\n> ダングリング参照によりプログラムは、 参照するつもりだったデータ以外のデータを参照してしまいます。\n\nhttps://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html\n\nダングリング参照という言葉は初めて聞いたが事象は知ってた。`free()` したオブジェクト（宙ぶらりんになってしまったポインタ）が残ってるやつ。\n\n> 無効なメモリ領域を指すポインタはダングリングポインタ（dangling pointer）と呼ばれる。\n> とりわけ、本来有効だったメモリ領域が解放処理などによって無効化されたにもかかわらず、そのメモリ領域を参照し続けているポインタのことを、ダングリングポインタと呼ぶ。\n> なお、ダングリングポインタは「ぶら下がりポインタ」と訳されることもある。\n\nhttps://marycore.jp/coding/dangling-pointer/\n\nダングル (dangle) は「ぶら下がる」という意味だそう。\n:::\n\n下記で借用チェックの説明にて、`'a` や `'b` を用いている。\n\nhttps://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html#%E5%80%9F%E7%94%A8%E7%B2%BE%E6%9F%BB%E6%A9%9F\n\n暗黙的にライフタイムをコンパイラが推測しているときはわざわざ宣言する必要はなかったが、ライフタイムの注釈がつくならばこうなるのだと改めて理解。\n\n下記の関数はエラーを吐く。\n\n```rust\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\nhttps://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html#%E9%96%A2%E6%95%B0%E3%81%AE%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%83%83%E3%82%AF%E3%81%AA%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0\n\n`fn longest(x: &str, y: &str) -> &str` は、型のことだけを考えれば正しいが、ライフタイムがわからないから。\n`x` と `y` のどっちのライフタイムが返ってくるんですか？　って話。\n\n下記の関数はコンパイルできる。\n\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\nhttps://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html#%E9%96%A2%E6%95%B0%E3%82%B7%E3%82%B0%E3%83%8B%E3%83%81%E3%83%A3%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E6%B3%A8%E9%87%88\n\n一見すると、引数として与えられる `x` も `y` もライフタイムが同じであることが条件であるようだが、実はどちらかライフタイムの短い方に依存する。"
    },
    {
      "author": "agdf",
      "created_at": "2023-06-30",
      "body_markdown": "## ライフタイム(2)\n\n構造体を持つ構造体を以下のように定義すると、コンパイルが通る。\n\n```rust\nstruct Parent<'a> {  \n   ref_chile: &'a Child  \n}  \n  \nstruct Child(usize);\n```\n\n> `Parent` は、フィールドにある `Child` の不変の参照よりもライフタイムが短い、ということをコンパイラに伝えている。\n\nhttps://blog-mk2.d-yama7.com/2020/12/20201230_rust_lifetime/\n\n親より先に死ぬ子供があってたまるか、という状態（？）。\n\n```rust\nimpl<'a> Parent<'a> {  \n    pub fn get_child_age(&self) -> usize {  \n        self.ref_child_a.0\n    }\n\n    pub fn compare_child_age(&'a self, another_child: &'a Child) -> &'a Child {  \n         if self.ref_child_a.0 > another_child.0 {  \n            self.ref_child_a  \n        } else {\n            another_child  \n        }  \n    }\n}\n```\n\n構造体にライフタイム注釈があるならば、メソッドでライフタイム注釈を使わなくとも、 `impl` は必ずライフタイム注釈を付ける必要がある。\n\nまた、 `compare_child_age` に関するライフタイム注釈を全て省略すると、下記のような推論が行われる。\n\n```rust\nfn compare_child_age(&'a self, another_child: &'b Child) -> &'a Child\n```\n\nこれは、ライフタイム省略規則というものが係るからである。\n\n> 1. 参照型の引数はそれぞれ独自のライフタイムをもつ（＝それぞれ異なるライフタイム注釈をつけることがでこきる）\n> 2. 引数の中で参照型が1つだけなら、その引数のライフタイムと戻り値（参照）のライフタイムと同一とみなす\n> 3. 第一引数が `&self` または `&mut self` ならば、戻り値（参照）のライフタイムは `self` と同一とみなす\n\n`1` より、ライフタイム注釈は各引数に対して個別に付けられ\n`3` より、戻り値のライフタイム注釈は `'a` と一緒になる\n\n:::details -\n引数のライフタイムは **入力ライフタイム** と呼ばれ、返り値のライフタイムは **出力ライフタイム** と呼ばれる。\n:::\n\n> 議論する必要のある1種の特殊なライフタイムが、 `'static` であり、これは、この参照がプログラムの全期間生存できる事を意味します。\n> この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。\n> 故に、全文字列リテラルのライフタイムは、 `'static` なのです。\n\n> エラーメッセージで、 `'static` を使用するようことがありますが、その参照が本当にプログラムの全期間生きるかどうか考えてください。 \n> ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。 \n> そのような場合、解決策はその問題を修正することであり、`'static` ライフタイムを指定することではありません。\n\nhttps://doc.rust-jp.rs/book-ja/ch10-03-lifetime-syntax.html#%E9%9D%99%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0\n\nトレイトの際に下記のような実装をしたが、上記の文章を読むと、 `'static` が適切ではないことがわかる。\n\n```rust\ntrait Entry {\n    fn get_name(&self) -> &'static str {\n        \"Undefined\"\n    }\n    fn get_parent(&self) -> &'static Self;\n    fn new(name: &str) -> Self;\n}\n```\n\n上記の学習に基づくと、下記のような実装でいいことになりそう。\n\n```rust\ntrait Entry<'a> {\n    fn get_name(&self) -> &str {\n        \"Undefined\"\n    }\n    fn get_parent(&self) -> &Self;\n    fn new(name: &str) -> Self;\n}\n```\n\n省略規則を適用するとこんな感じか\n\n```rust\ntrait Entry<'a> {\n    fn get_name(&'a self) -> &'a str {\n        \"Undefined\"\n    }\n    fn get_parent(&'a self) -> &'a Self;\n    fn new(name: &'a str) -> Self;\n}\n```\n\n`Entry` トレイト内のライフタイムは全て `<'a>` と同等か、それより長く生存すると想定するならば、これであっていることになる。\n\n"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-01",
      "body_markdown": "## トレイト(2)\n\nトレイトは継承を行うことができる。\n\n```rust\npub trait Geometry {\n    ...\n}\n\npub trait Drawable: Geometry {\n    ...\n}\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/497a21#%F0%9F%93%8C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E7%B6%99%E6%89%BF\n\n> ある型から別の型に変換するとき、便利な `From` トレイトというのがあります。\n> `from` メソッドを対応した型ごとに実装することで、その型から `into` メソッドで変換できます。\n\n```rust\n#[derive(Debug)]\nstruct Point { x: f64, y: f64 }\n\nimpl From<f64> for Point {\n    fn from(input: f64) -> Self {\n        Point { x: input, y: input }\n    }\n}\n\nfn main() {\n    let p1 = Point::from(1.0);\n    let p2: Point = (1.0).into();\n    println!(\"{:?} {:?}\", p1, p2);\n}\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/497a21#%F0%9F%93%8C-from-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88\n\n型を指定してあげなくても先の方を予測して勝手に変換してくれる仕組み、便利だなぁと思いつつ実装方法を知らなかった。"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-01",
      "body_markdown": "## RAII(1)\n\n> リソースの確保をオブジェクトの初期化時に行い、リソースの開放をオブジェクトの破棄と同時に行う手法。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/063df5#%F0%9F%93%8C-raii%E3%81%A8%E3%81%AF\n\nhttps://doc.rust-jp.rs/rust-by-example-ja/scope/raii.html\n\nスコープから抜けたら所有権が破棄されるのは既知のとおりだが、C/C++のような言語だと、リソースの開放を自動的にやってくれる訳では無い。そうしたいなら `std::unique_ptr` を使う必要がある。\nRust では明示的に破棄をする必要はないが、それを明示的にするにはどうするべきか、が記述されている。\n\nヒープメモリを確保するには、 `Box<T>::new` を使用する。\n\n```rust\nlet a = Box::new(10);        // type inference\nlet a = Box::<i32>::new(20); // explicit type\nlet a = 30;                  // immutable object\nlet b = Box::new(a);         // move object from stack memory to heap memory\nlet c = *b;                  // dereference\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/063df5#%F0%9F%93%8C-box%E5%9E%8B\n\nBox を使う例として二分木がある。\n\n```rust\nstruct BinaryTree<T: std::cmp::PartialOrd + std::fmt::Display> {\n    val: T,\n    left: Option<Box<BinaryTree<T>>>,\n    right: Option<Box<BinaryTree<T>>>,\n}\n\nimpl<T: std::cmp::PartialOrd  + std::fmt::Display> BinaryTree<T> {\n    fn new(val: T) -> Self {\n        Self {\n            val,\n            left: None,\n            right: None,\n        }\n    }\n\n    fn insert(&mut self, val: T) {\n        if val < self.val {        \n            println!(\"insert value {val} to left\");\n            self.insert_left(val);\n        } else {\n            println!(\"insert value {val} to right\");\n            self.insert_right(val);\n        }\n    }\n\n    fn insert_left(&mut self, val: T) {\n        match &mut self.left {\n            Some(left) => {\n                // left..insert(val);\n                left.insert(val);\n            }\n            None => {\n                self.left = Box::new(BinaryTree::new(val)).into();\n            }\n        }\n    }\n\n    fn insert_right(&mut self, val: T) {\n        match &mut self.right {\n            Some(right) => {\n                right.insert(val);\n            }\n            None => {\n                self.right = Box::new(BinaryTree::new(val)).into();\n            }\n        }\n    }\n}\n```\n\n動作ほぼ未確認だがだいたいこんな感じ。",
      "body_updated_at": "2023-07-01"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-01",
      "body_markdown": "## RAII(2)\n\n> 同じオブジェクトを複数から束縛することを可能にするのが参照カウンタ `Rc<T>` 。\n> Rc型はオブジェクトをヒープメモリに置くので、`Box` の代わりに使うことができる。\n\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(10);\nlet b = Rc::clone(&a);\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/063df5#%F0%9F%93%8C-rc\n\nこの入門記事では「ポインタ」という言葉を避けているが、この `Rc<T>` は、 C++ でいう `std::shared_ptr` であると理解した。\n\n複数の変数に同じオブジェクトへの所有権をもたせ、全てが破棄された時点でメモリの開放を行う。\n\nまた、 `Arc<T>` はスレッドセーフな参照カウンタである。\n\n```rust\nuse std::rc::Rc;\n\nfn main() {\n    let foo = Rc::new(50);\n\n    // reference count = 1\n    println!(\"reference count :{}\",Rc::strong_count(&foo));\n\n    let bar = Rc::clone(&foo);\n\n    // reference count = 2\n    println!(\"reference count :{}\",Rc::strong_count(&bar));\n\n    // &foo == &bar\n    println!(\"foo = {:p}\", foo);\n    println!(\"bar = {:p}\", bar);\n}\n```\n\nhttps://dev.classmethod.jp/articles/rust-smart-pointer/\n\nただ、`Rc` で値を取ってきても可変ではないので、書き換えることはできない。"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-01",
      "body_markdown": "## 内部可変性(1)\n\n`Cell<T>` を用いると、`mut` 宣言しなくとも値を変更することができる。\n\n```rust\nuse std::cell::Cell;\n\nfn main() {\n    let a = Cell::new(10); // immutable object with interior mutability\n    dbg!(a.get()); // a.get() = 10\n    a.set(20);\n    dbg!(a.get()); // a.get() = 20\n\n    let b = a.replace(10);\n    dbg!(a.get()); // a.get() = 10\n    dbg!(b);       // b = 20\n    \n    let c = a.into_inner(); // turn Cell<T> into T\n    dbg!(c);       // c = 10\n    dbg!(a);       // borrow check - Error\n}\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/5df75e#%F0%9F%93%8C-%E5%86%85%E9%83%A8%E5%8F%AF%E5%A4%89%E6%80%A7\n\n`get/set` はそのままなので置いといて、\n`replace` は内部の値を変更しつつ、以前の値をポップアウトする。\n`into_inner` はポップアウトする。\n\nこの `Cell<T>` と、先の `Rc<T>` を組み合わせて、可変な `std::shared_ptr` を作り出す。\n\n```rust\nfn main() {\n    let a = Rc::new(Cell::new(10));\n    a.set(20);\n    dbg!(a.get()); // a.get() = 20\n\n    let b = Rc::clone(&a);\n    b.set(30);\n    dbg!(a.get()); // a.get() = 30\n}\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/5df75e#%F0%9F%93%8C-%E5%86%85%E9%83%A8%E5%8F%AF%E5%A4%89%E6%80%A7",
      "body_updated_at": "2023-07-01"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-01",
      "body_markdown": "## 関数、クロージャ(1)\n\n> クロージャはそれぞれ独自の型を持っています。\n> クロージャは `Fn` トレイト、 `FnMut` トレイト、 `FnOnce` トレイトのどれかのインスタンスです。\n> それぞれ `&self`、`&mut self`、`self` を内部的に引数として受け取っているかどうかの違いがあります。\n> また、`Fn` トレイトは `FnMut` トレイトを、 `FnMut` トレイトは `FnOnce` トレイトを継承しています。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3%E3%81%A8%E3%81%AF\n\n> `fn` は関数定義で使いますが、 `fn` は型でもあります。\n> そして、 `fn` のことを **関数ポインタ** と言います。\n> `fn` は `Fn` トレイトのインスタンスなので、 `FnMut` トレイト、 `FnOnce` トレイトのインスタンスでもあります。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-fn-%E3%81%A8-fn\n\n急にようわからんこと&知らんことがいっぱい出てきた。ので詳細に書いている記事を漁った。\n\n```rust\nfn main() {\n    let closures = [3, 7, 1, 5, 8, 9, 2].iter().map(|&i| {\n        move |j| i + j\n    }).collect::<Vec<_>>();\n    println!(\"{}\", closures[3](14));\n}\n```\n\n> というコードでは、「3を足す関数」「7を足す関数」「1を足す関数」「5を足す関数」…… のようにたくさんの「関数」を動的に生成していますが、こういうのはクロージャでないとできません。\n\nhttps://qnighy.hatenablog.com/entry/2018/02/11/220000\n\n`move` ？　なんだこれ\nと思ったので更に調べる。\n\n```rust\n// moveするクロージャ\nlet mut num = 0;\n// 本当は所有権がムーブするが、数値はCopyな型なのでコピーされる\nlet mut ref_cls = move || {\n    num += 1;\n    num\n};\nassert_eq!(ref_cls(), 1);\n// numはクロージャとは無関係になったので影響を受けない\nassert_eq!(num, 0);\n\n// moveするクロージャ\nlet s = \"String\".to_string();\nlet ref_cls = move || {\n    println!(\"{}\", s);\n};\n// `s`は既にムーブしているので使うとエラー\n// println!(\"{}\", s);\n```\n\nhttps://teratail.com/questions/377403\n\n本当に所有権が移るようになるっぽい。\n\n```rust\nfn main() {\n    let x = vec![1, 2, 3];\n\n    let equal_to_x = move |z| z == x;\n\n    // ここでは、xを使用できません: {:?}\n    println!(\"can't use x here: {:?}\", x);\n\n    let y = vec![1, 2, 3];\n\n    assert!(equal_to_x(y));\n}\n```\n\nhttps://doc.rust-jp.rs/book-ja/ch13-01-closures.html\n\n読むたび何か大事なことをすっぽかしているような気がするので、公式ドキュメントを読み返すことに。\n",
      "body_updated_at": "2023-07-01"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-02",
      "body_markdown": "## 関数、クロージャ(2)\n\n実行に時間がかかる処理を持つ関数を呼び出すのを、不要なら呼び出さず、なおかつ2回以上呼び出す場合は前回の値を流用してね、というような処理を作るチュートリアル。\nその中でキャッシュをもたせる構造体を作成したが、限界を悟ってクロージャを用いようねっていう流れになっていた。\n\nhttps://doc.rust-jp.rs/book-ja/ch13-01-closures.html\n\nその中で `Fn` `FnMut` `FnOnce` の説明が入っていた。\n\n直感的には、\n`FnOnce` は `move || {}` に実装されるトレイトで、クロージャ内でキャプチャした変数に所有権を渡す。所有権は二回以上奪うことができないので、`Once` という名前がついている。\n`FnMut` はクロージャ内で可変で値を借用する。\n`Fn` は不変で借用する。\n\nという感じ。\n\n`move` は並列処理で多く出てくるそう。\n\nで関数ポインタ、関数定義型って？\n\n関数を参照するポインタが関数ポインタなんだろうというところはわかるが、「`fn` が関数ポインタ」という文言がわからない。\n\n> 関数は、型 `fn` に型強制されます。 \n> `fn` 型は、関数ポインタと呼ばれます。 \n\nhttps://doc.rust-jp.rs/book-ja/ch19-05-advanced-functions-and-closures.html#%E9%96%A2%E6%95%B0%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF\n\nうーん"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-02",
      "body_markdown": "## 関数、クロージャ(3)\n\n```rust\nfn type_of<T>(_: T) -> String {\n    let a = std::any::type_name::<T>();\n    return a.to_string();\n}\n\nfn double(value: i32) -> i32 {\n    value * 2\n}\n\nlet f1: fn(i32) -> i32 = double;\nlet f2 = double;\n\nprintln!(\"function pointer: {}\", type_of(f1)); // function pointer: fn(i32) -> i32\nprintln!(\"function pointer: {}\", type_of(f2)); // function pointer: calc::main::double\n```\n\nhttps://yukimemo.hatenadiary.jp/entry/2021/01/24/152948\n\n型を示してポインタとして受け取るならばそれは関数ポインタとなり、そうでない場合は関数定義型になる。\n\nhttps://doc.rust-lang.org/reference/types/function-item.html\n\nイマイチ腑に落ちないのでとりあえずさようなら。\n\n下記のコードはコンパイルが通らない。返すのが型ではないから。\n\n```rust\nfn returns_closure() -> Fn(i32) -> i32 {\n    |x| x + 1\n}\n```\n\n通すだけならば以下の通り。\n\n```rust\nfn returns_closure() -> fn(i32) -> i32 {\n    |x| x + 1\n}\n\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n\nfn returns_closure<'a>() -> &'a (dyn Fn(i32) -> i32) {\n    &|x| x + 1\n}\n\nfn returns_closure() -> Box<dyn Fn(i32) -> i32>{\n    Box::new(|x| x + 1)\n}\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-sized-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88\n\n`dyn` と、ここについてくる `impl` がわからない。\n\n```rust\ntrait Trait {}\n\nimpl Trait for i32 {}\n\n// old\n// いままで\nfn function1() -> Box<Trait> {}\n\n// new\n// これから\nfn function2() -> Box<dyn Trait> {}\n```\n\n> トレイトオブジェクトにトレイト名をそのまま使うのは悪手だった。\n\nhttps://doc.rust-jp.rs/edition-guide/rust-2018/new-keywords.html\n\n> 静的ディスパッチ - コンパイル時に呼び出すべきメソッドを決める、決まる。\n> 動的ディスパッチ - 実行時にオブジェクトの型を調べ、対応するメソッドを呼び出す。\n\nhttps://blog.ojisan.io/rust-dispatch/\n\nトレイトだけを指定すると、その引数にやってくる実態が何かはコンパイラにはわからない。\n動的ディスパッチを用いて、実行時にその実態を知ってもらうようにしてあげる。\n\n> 関数がトレイトを実装した型を返す場合、 `impl Trait` という書き方ができる。\n\nhttps://doc.rust-lang.org/rust-by-example/trait/impl_trait.html#as-a-return-type\n\n関数の引数に `&impl` って書くやつと変わらんかったしたしかにそうだった。\n\nいずれにしても全て本質的には返り値が違うので、注意しなければならない。\nでも具体的にどう言う場面でどう注意したらいいかは思いつかない。",
      "body_updated_at": "2023-07-02"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-02",
      "body_markdown": "## 関数、クロージャ(4)\n\n下記のコードはコンパイルが通らない。\n\n```rust\nfn put<T: std::fmt::Debug>(a: &T) {\n    println!(\"{:?}\", a);\n}\n\nfn main() {\n    put(\"hoge\");\n}\n```\n\n> **動的サイズ型** は、実行時にサイズが決まる型で、`str` 型などはそれにあたる。\n> そうでない、つまり、型のサイズが予め推論できるとき、Rust ではその型を自動的に `Sized` トレイトのインスタンスにする。\n> つまり、関数の引数やジェネリック型などは `Sized` トレイトのインスタンスでなければならない。\n\n> `str` は動的サイズ型なので参照を付けていますが、これはエラーになってしまいます。\n> これは暗黙的に `T: Sized` となっているためで、引数側に参照を付けても `T` が `Sized` トレイトのインスタンスでなければなりません。\n> しかし、引数側で参照を付けているので、コードとしては動的サイズ型を指定しても問題ありません。\n> そこで、 `T` が動的サイズ型を受け入れられるように `?Sized` を指定するこができます。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-sized-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88\n\nジェネリック型や関数の引数が `Sized` トレイトのインスタンスであり、 `str` は動的サイズ型なので、 `&str` としたとしても `str` は `T` にはなり得ない（`Sized` トレイトのインスタンスになり得ない）ので、エラーになってしまう。\nで、`?Sized` を指定する必要があるが、 `?` ってなんすか。\n\nこれ系の解説記事を探していると、 `fat pointer` という言葉が時折出てくる。\n\n> 自作スライスの説明で fat pointer という言葉が出てきた。\n> 生ポインタと補助的な情報 (スライスなら長さ) を合わせた構造のことを指すらしい。\n> Rust 特有の用語ではなく、GC 本では dangling pointer の検出方法の一つとして紹介されている。\n\nhttps://twitter.com/nhiroki_/status/1193664095297269760?lang=ja\n\n> \"fat pointer\" とは、動的サイズ型への生ポインタや参照のこと。\n> 動的なサイズのヒープバッファを管理する型（`Vec<T>` など）も、コンパイラは `Vec<T>` インスタンスがスタックに占める正確なバイト数を知っているので、`Sized` である。\n> スライス ([T], str) や、トレイト (dyn Trait) は動的サイズ型である。 \n\nhttps://stackoverflow.com/questions/57754901/what-is-a-fat-pointer\n\n> Sizedを実装する型は、全て同じバイト数である。\n> C言語のsizeofに相当するstd::mem::size_of が使える。\n> (Sizedでない場合は値によって異なるため、std::mem::size_of_valを使う)\n\n> これらの値へのポインタは `16byte` になる。\n> 最初の `8byte` にはデータの先頭番地が入っている。\n> 続く `8byte` には、スライスの要素数や、バイト数などが入っている。\n\nhttps://qnighy.hatenablog.com/entry/2017/03/04/131311\n\nfat pointer については大まかにわかった。\n\n> 特別な記法 `?Sized` は、`Sized` トレイトを実装しなくてはならないという制約を回避させてくれる。\n\nhttps://doc.rust-lang.org/std/marker/trait.Sized.html\n\n`?<Trait>` が特殊な文法なのでは？\nと思ったが、コンパイラ怒られたので `?Sized` 専用。"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-03",
      "body_markdown": "## 関数、クロージャ(5)\n\n> クロージャはトレイトであり、動的サイズ型であり、参照やBox型を使うことでオブジェクトとして扱えるようになります。\n> このようなオブジェクトをトレイトオブジェクトといいます。\n> トレイトオブジェクトを扱う側は実際のオブジェクトの型を知らなくても、そのメソッドを呼び出せるということ、\n> そしてオブジェクトの型によってメソッドの動作を変えられることになります。\n> これらの仕組みを **動的ディスパッチ** といいます。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-%E9%9D%99%E7%9A%84%E3%81%A8%E5%8B%95%E7%9A%84\n\n動的ディスパッチをクロージャやトレイトの始点から語っている。\nそして、以下のものが静的ディスパッチであることを述べている。\n\n```rust\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n```\n\n`Box<&dyn Trait>` で実装するものが動的ディスパッチで、 `impl Trait` で実装するものが静的ディスパッチ。\n多分動的ディスパッチのほうが遅くなるだろう、という直感はあるので、制約を緩めたいときに動的ディスパッチを用いるという具合か。\n\n`impl Trait` は抽象型ともいうらしい。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/64c6f3#%F0%9F%93%8C-%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%82%AF%E3%82%B9%E3%81%A8%E6%8A%BD%E8%B1%A1%E5%9E%8B"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-03",
      "body_markdown": "## スレッド(1)\n\nスレッドを作成、終了させるには、以下のようにする。\n\n```rust\nuse std::thread;\nlet handle = thread::spawn(|| {\n    // thread code\n});\n\nhandle        // JoinHandle 型\n    .join()   // Result 型\n    .unwrap();\n```\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/98dc80#%F0%9F%93%8C-%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89\n\n> クロージャの環境をスレッド間で共有することは通常の方法ではできません。\n> コピーを作成できるなら、環境にコピーされますが、そうでない（`Vec<T>` など）なら所有権を移動しなければなりません。\n> その場合は `move || { /* thread code here */ }` を使います。\n\n> 複数のスレッド間で状態を共有するには`Mutex` 型で **排他制御** をする。\n> `lock` メソッドでリソースをロックし、 `LockResult` 型を返す。\n> `LockResult` 型は `RAII` である `MutexGuard` 型のオブジェクトを束縛しているので、自動でロックを解除する。\n\n> オブジェクトをスレッド間で共有するには、`Rc` 型のマルチスレッド版である `Arc` 型を使う必要があります。\n\nhttps://zenn.dev/mebiusbox/books/22d4c1ed9b0003/viewer/98dc80#%F0%9F%93%8C-%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89\n\nRust のスレッドは OS スレッドで、Golang や Java などのような言語はグリーンスレッドと言い、違いとしては、仮想マシン上でマルチスレッドを実現するかというところらしい。\n\nhttps://zenn.dev/tfutada/articles/16766e3b4560db#%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89\n\n非同期処理は下記のような形で行う。\n\n```rust\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel(); // 非同期チャネルを生成\n\n    thread::spawn(move || {\n        tx.send(42).unwrap(); // (非同期)送信\n        println!(\"Done immediately!\"); // すぐにこの行に処理を移します\n    });\n    \n    thread::sleep(Duration::from_secs(3)); // メインスレッドの処理を少し遅らせる\n\n    println!(\"got {}\", rx.recv().unwrap()); // 受信\n}\n```\n\nhttps://zenn.dev/tfutada/articles/16766e3b4560db#%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%83%81%E3%83%A3%E3%83%8D%E3%83%AB\n\n同期処理は下記のような形で行う。\nバッファサイズを `1` にすると、送信はブロックされないが、同期処理を行うらしい。\n\n```rust\nuse std::sync::mpsc::sync_channel;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = sync_channel::<i32>(0); // バッファサイズを０にする\n    thread::spawn(move || {\n        tx.send(53).unwrap(); // 同期送信。受け取ってもらうまで待ちます。\n        println!(\"Done after 3sec!\"); // すぐには処理されません\n    });\n\n    thread::sleep(Duration::from_secs(3));\n\n    println!(\"got {}\", rx.recv().unwrap());\n}\n```\n\nhttps://zenn.dev/tfutada/articles/16766e3b4560db#%E5%90%8C%E6%9C%9F%E3%83%81%E3%83%A3%E3%83%8D%E3%83%AB\n\n* バッファが **いっぱいになると `send` はブロック** される\n\nhttps://scrapbox.io/nwtgck/Rust%E3%81%AEstd::mpsc::sync_channel(bound)%E3%81%AE%E5%BC%95%E6%95%B0bound%E3%81%AF%E4%BD%95%E3%81%8B%EF%BC%9F\n\nバッファのことがよく分からなかったので、ちょっと実験してみる。\n\n```rust\nlet buffer_size = 0;\n\nlet (tx, rx) = sync_channel::<i32>(buffer_size);\nthread::spawn(move || {\n    tx.send(1).unwrap();\n    println!(\"Done\");\n});\n\nthread::sleep(Duration::from_secs(3));\n\nprintln!(\"got {}\", rx.recv().unwrap());\n```\n\n```\n> got 1\n> Done\n```\n\n```rust\nlet buffer_size = 1;\n\nlet (tx, rx) = sync_channel::<i32>(buffer_size);\nthread::spawn(move || {\n    tx.send(1).unwrap();\n    println!(\"Done\");\n});\n\nthread::sleep(Duration::from_secs(3));\n\nprintln!(\"got {}\", rx.recv().unwrap());\n```\n\n```\n> Done\n> got 1\n```\n\n```rust\nlet buffer_size = 1;\n\nlet (tx, rx) = sync_channel::<i32>(buffer_size);\nthread::spawn(move || {\n    tx.send(1).unwrap();\n    tx.send(2).unwrap();\n    println!(\"Done\");\n});\n\nthread::sleep(Duration::from_secs(3));\n\nprintln!(\"got {}\", rx.recv().unwrap());\nprintln!(\"got {}\", rx.recv().unwrap());\n```\n\n```\n> got 1\n> got 2\n> Done\n```\n\nバッファサイズが `2` になると、`tx.send(2).unwrap();` で処理が止まっている（であろう）様子がうかがえる。\n\nひとまずスレッドはこのあたりで。"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-03",
      "body_markdown": "## マクロ(1)\n\nマクロの作成方法が気になっていた。\n\nそもそもマクロには種類がある。\n\n> * `macro_rules!` を使った **宣言的 (declarative) マクロ**\n> * 3種類の **手続き的 (procedural) マクロ**：\n>     * 構造体と `enum` に `derive` 属性を使ったときに追加されるコードを指定する `#[derive]`\n>     * 任意の要素に使えるカスタムの属性を定義する、属性風のマクロ\n>     * 関数のように見えるが、引数として指定されたトークンに対して作用する関数風のマクロ\n\nまた、\n\n> 関数シグニチャは、関数の引数の数と型を宣言しなければなりません。\n> 一方、マクロは可変長の引数を取れます。\n> `println!(\"hello\")` のように1引数で呼んだり、\n> `println!(\"hello {}\", name)` のように2引数で呼んだりできる。\n\n気にしていなかったが、言われてみればたしかにそうだ。\n\nhttps://man.plustar.jp/rust/book/ch19-06-macros.html#%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A8%E9%96%A2%E6%95%B0%E3%81%AE%E9%81%95%E3%81%84\n\n下記は簡略化された `vec!` マクロである。\n\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n```\n\n> `#[macro_export]` 注釈は、マクロを定義しているクレートがスコープに持ち込まれたなら、\n> 無条件でこのマクロが利用可能になるべきということを示している。\n\n> 将来、Rustには別種の宣言的マクロが登場する予定です。\n> そのアップデート以降、 `macro_rules!` は事実上非推奨となる予定です。 \n\nhttps://man.plustar.jp/rust/book/ch19-06-macros.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E3%83%A1%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%81%9F%E3%82%81%E3%81%ABmacro_rules%E3%81%A7%E5%AE%A3%E8%A8%80%E7%9A%84%E3%81%AA%E3%83%9E%E3%82%AF%E3%83%AD\n\n`match` 式のようなもので、正規表現のようなキャプチャをし、そのアームの先に書かれていることに基づいて式が展開されるという具合らしいが、非推奨になるならあまり深入りはしないことにする。\n\n以降色々読んでみたが、あまり得たい情報は得られなかった気がするし、複雑なものは自分で定義するべきでもないような気もした。"
    },
    {
      "author": "agdf",
      "created_at": "2023-07-10",
      "body_markdown": "なんやかんやで紙に書くお勉強に戻ってしまったので閉じます"
    }
  ]
}